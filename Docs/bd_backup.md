# üíæ **Bancos NoSQL - Database per Service**

## üéØ **O que √© Database per Service?**
O padr√£o "Database per Service" √© um princ√≠pio fundamental da arquitetura de microsservi√ßos onde **cada servi√ßo possui seu pr√≥prio banco de dados independente**. No nosso projeto, utilizamos arquivos JSON como bancos NoSQL para simplicidade e demonstra√ß√£o dos conceitos.

---

## üìÅ **Estrutura dos Bancos de Dados - Implementa√ß√£o Real**

### **Bancos Implementados no Projeto:**
```
üìÇ Bancos NoSQL (Database per Service)
‚îú‚îÄ‚îÄ üë§ services/user-service/database/users.json
‚îú‚îÄ‚îÄ üì¶ services/item-service/database/items.json
‚îú‚îÄ‚îÄ üìÇ services/item-service/database/categories.json
‚îî‚îÄ‚îÄ üìã services/list-service/database/lists.json
```

### **Localiza√ß√£o dos Arquivos:**
- **User Service:** `C:\PUC_2025_2\DAMD\ListaComprasMS\services\user-service\database\users.json`
- **Item Service:** `C:\PUC_2025_2\DAMD\ListaComprasMS\services\item-service\database\items.json`
- **Categories:** `C:\PUC_2025_2\DAMD\ListaComprasMS\services\item-service\database\categories.json`
- **List Service:** `C:\PUC_2025_2\DAMD\ListaComprasMS\services\list-service\database\lists.json`

### **Caracter√≠sticas dos Bancos JSON:**
- ‚úÖ **Autonomia total** - Cada servi√ßo controla seus dados
- ‚úÖ **Schema flex√≠vel** - Estrutura adapt√°vel
- ‚úÖ **Backup independente** - Prote√ß√£o individual
- ‚úÖ **Escalabilidade** - Crescimento isolado

---

## ‚ö†Ô∏è **Problema: Consist√™ncia em Caso de Falhas**

### **Cen√°rio Cr√≠tico:**
Quando um servi√ßo falha e um backup √© ativado, como garantir que os dados permane√ßam consistentes entre os servi√ßos?

---

## üîÑ **Estrat√©gias de Consist√™ncia Implementadas no Projeto**

### **1. Health Checks e Circuit Breaker (Implementa√ß√£o Real)**

**Arquivo:** `api-gateway/server.js` (linhas 477-502)

```javascript
// Health checks autom√°ticos
startHealthChecks() {
    console.log('üîÑ Iniciando health checks autom√°ticos...');
    
    setInterval(async () => {
        try {
            const services = serviceRegistry.listServices();
            
            for (const [serviceName, serviceInfo] of Object.entries(services)) {
                try {
                    const response = await axios.get(`${serviceInfo.url}/health`, { timeout: 5000 });
                    serviceRegistry.updateHealthCheck(serviceName, true);
                    this.resetCircuitBreaker(serviceName);
                } catch (error) {
                    serviceRegistry.updateHealthCheck(serviceName, false);
                    console.log(`‚ö†Ô∏è  Health check falhou para ${serviceName}: ${error.message}`);
                }
            }
            
            // Cleanup de servi√ßos inativos
            serviceRegistry.cleanupInactiveServices();
            
        } catch (error) {
            console.error('Erro nos health checks:', error);
        }
    }, 30000); // A cada 30 segundos
}
```

### **2. Circuit Breaker para Prote√ß√£o (Implementa√ß√£o Real)**

**Arquivo:** `api-gateway/server.js` (linhas 445-474)

```javascript
// Registro de falhas e prote√ß√£o
recordFailure(serviceName) {
    let breaker = this.circuitBreakers.get(serviceName) || {
        failures: 0,
        isOpen: false,
        isHalfOpen: false,
        lastFailure: null
    };

    breaker.failures++;
    breaker.lastFailure = Date.now();

    // Abrir circuito ap√≥s 3 falhas
    if (breaker.failures >= 3) {
        breaker.isOpen = true;
        breaker.isHalfOpen = false;
        console.log(`Circuit breaker opened for ${serviceName}`);
    }

    this.circuitBreakers.set(serviceName, breaker);
}

// Reset do Circuit Breaker
resetCircuitBreaker(serviceName) {
    const breaker = this.circuitBreakers.get(serviceName);
    if (breaker) {
        breaker.failures = 0;
        breaker.isOpen = false;
        breaker.isHalfOpen = false;
        console.log(`Circuit breaker reset for ${serviceName}`);
    }
}
```

### **3. Service Registry com Health Tracking (Implementa√ß√£o Real)**

**Arquivo:** `lista-compras-microservices/shared/serviceRegistry.js` (linhas 104-117)

```javascript
// Atualizar status de health check
updateHealthCheck(serviceName, isHealthy) {
    const services = this.readRegistry();
    if (services[serviceName]) {
        services[serviceName].lastHealthCheck = Date.now();
        services[serviceName].healthy = isHealthy;
        this.writeRegistry(services);
        
        if (!isHealthy) {
            console.log(`‚ö†Ô∏è Servi√ßo ${serviceName} marcado como n√£o saud√°vel`);
        } else {
            console.log(`‚úÖ Servi√ßo ${serviceName} marcado como saud√°vel`);
        }
    }
}
```

**Arquivo:** `lista-compras-microservices/shared/serviceRegistry.js` (linhas 120-137)

```javascript
// Limpar servi√ßos inativos (failover autom√°tico)
cleanupInactiveServices(timeoutMs = 300000) { // 5 minutos
    const services = this.readRegistry();
    const now = Date.now();
    let cleaned = 0;
    
    Object.entries(services).forEach(([name, service]) => {
        const timeSinceLastCheck = now - service.lastHealthCheck;
        
        if (timeSinceLastCheck > timeoutMs) {
            console.log(`üóëÔ∏è Removendo servi√ßo inativo: ${name} (√∫ltimo check: ${timeSinceLastCheck}ms atr√°s)`);
            delete services[name];
            cleaned++;
        }
    });
    
    if (cleaned > 0) {
        this.writeRegistry(services);
        console.log(`‚úÖ ${cleaned} servi√ßos inativos removidos do registry`);
    }
}
```

### **4. Health Check Endpoints nos Servi√ßos (Implementa√ß√£o Real)**

**Arquivo:** `services/user-service/server.js` (linhas 86-105)

```javascript
// Health check endpoint
this.app.get('/health', async (req, res) => {
    try {
        const userCount = await this.usersDb.count();
        res.json({
            service: this.serviceName,
            status: 'healthy',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
            version: '1.0.0',
            database: {
                type: 'JSON-NoSQL',
                userCount: userCount
            }
        });
    } catch (error) {
        res.status(503).json({
            service: this.serviceName,
            status: 'unhealthy',
            error: error.message
        });
    }
});
```

**Arquivo:** `services/item-service/server.js` (linhas 52-73)

```javascript
// Health check endpoint
this.app.get('/health', async (req, res) => {
    try {
        const itemCount = await this.itemsDb.count();
        const categoryCount = await this.categoriesDb.count();
        res.json({
            service: this.serviceName,
            status: 'healthy',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
            version: '1.0.0',
            database: {
                type: 'JSON-NoSQL',
                itemCount: itemCount,
                categoryCount: categoryCount
            }
        });
    } catch (error) {
        res.status(503).json({
            service: this.serviceName,
            status: 'unhealthy',
            error: error.message
        });
    }
});
```

**Arquivo:** `services/list-service/server.js` (linhas 52-73)

```javascript
// Health check endpoint
this.app.get('/health', async (req, res) => {
    try {
        const listCount = await this.listsDb.count();
        res.json({
            service: this.serviceName,
            status: 'healthy',
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
            version: '1.0.0',
            database: {
                type: 'JSON-NoSQL',
                listCount: listCount
            }
        });
    } catch (error) {
        res.status(503).json({
            service: this.serviceName,
            status: 'unhealthy',
            error: error.message
        });
    }
});
```

---

### **5. JsonDatabase - Gerenciamento de Dados (Implementa√ß√£o Real)**

**Arquivo:** `lista-compras-microservices/shared/JsonDatabase.js` (linhas 1-50)

```javascript
// Classe gen√©rica para gerenciamento de bancos JSON
class JsonDatabase {
    constructor(databasePath, collectionName) {
        this.databasePath = databasePath;
        this.collectionName = collectionName;
        this.filePath = path.join(databasePath, `${collectionName}.json`);
        
        // Garantir que o diret√≥rio existe
        fs.ensureDirSync(databasePath);
        
        // Inicializar arquivo se n√£o existir
        this.initializeFile();
    }

    initializeFile() {
        if (!fs.existsSync(this.filePath)) {
            fs.writeFileSync(this.filePath, JSON.stringify([], null, 2));
            console.log(`‚úÖ Arquivo de banco criado: ${this.filePath}`);
        }
    }

    async read() {
        try {
            const data = fs.readFileSync(this.filePath, 'utf8');
            return JSON.parse(data);
        } catch (error) {
            console.error(`Erro ao ler ${this.filePath}:`, error);
            return [];
        }
    }

    async write(data) {
        try {
            fs.writeFileSync(this.filePath, JSON.stringify(data, null, 2));
            return true;
        } catch (error) {
            console.error(`Erro ao escrever ${this.filePath}:`, error);
            return false;
        }
    }

    async create(item) {
        const data = await this.read();
        const newItem = {
            id: uuidv4(),
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            ...item
        };
        
        data.push(newItem);
        await this.write(data);
        return newItem;
    }
}
```

**Arquivo:** `services/user-service/server.js` (linhas 30-34)

```javascript
// Inicializa√ß√£o do banco de dados no User Service
setupDatabase() {
    const dbPath = path.join(__dirname, 'database');
    this.usersDb = new JsonDatabase(dbPath, 'users');
    console.log('User Service: Banco NoSQL inicializado');
}
```

**Arquivo:** `services/item-service/server.js` (linhas 28-33)

```javascript
// Inicializa√ß√£o dos bancos de dados no Item Service
setupDatabase() {
    const dbPath = path.join(__dirname, 'database');
    this.itemsDb = new JsonDatabase(dbPath, 'items');
    this.categoriesDb = new JsonDatabase(dbPath, 'categories');
    console.log('Item Service: Banco NoSQL inicializado');
}
```

**Arquivo:** `services/list-service/server.js` (linhas 28-32)

```javascript
// Inicializa√ß√£o do banco de dados no List Service
setupDatabase() {
    const dbPath = path.join(__dirname, 'database');
    this.listsDb = new JsonDatabase(dbPath, 'lists');
    console.log('List Service: Banco NoSQL inicializado');
}
```

---

### **6. Proxy com Failover Autom√°tico (Implementa√ß√£o Real)**

**Arquivo:** `api-gateway/server.js` (linhas 304-335)

```javascript
// Proxy request to service com failover
async proxyRequest(serviceName, req, res, next) {
    try {
        console.log(`üîÑ Proxy request: ${req.method} ${req.originalUrl} -> ${serviceName}`);
        
        // Verificar circuit breaker
        if (this.isCircuitOpen(serviceName)) {
            console.log(`‚ö° Circuit breaker open for ${serviceName}`);
            return res.status(503).json({
                success: false,
                message: `Servi√ßo ${serviceName} temporariamente indispon√≠vel`,
                service: serviceName
            });
        }

        // Descobrir servi√ßo
        let service;
        try {
            service = serviceRegistry.discover(serviceName);
        } catch (error) {
            console.error(`‚ùå Erro na descoberta do servi√ßo ${serviceName}:`, error.message);
            
            // Debug: listar servi√ßos dispon√≠veis
            const availableServices = serviceRegistry.listServices();
            console.log(`üìã Servi√ßos dispon√≠veis:`, Object.keys(availableServices));
            
            return res.status(503).json({
                success: false,
                message: `Servi√ßo ${serviceName} n√£o encontrado`,
                service: serviceName,
                availableServices: Object.keys(availableServices)
            });
        }
        
        // ... resto da implementa√ß√£o do proxy
    } catch (error) {
        // Registrar falha
        this.recordFailure(serviceName);
        
        console.error(`‚ùå Proxy error for ${serviceName}:`, {
            message: error.message,
            status: error.response?.status,
            url: error.config?.url
        });

        // Encaminhar erro do servi√ßo ou retornar erro do gateway
        if (error.response) {
            console.log(`üîÑ Encaminhando erro ${error.response.status} do servi√ßo`);
            return res.status(error.response.status).json(error.response.data);
        } else {
            return res.status(503).json({
                success: false,
                message: `Servi√ßo ${serviceName} indispon√≠vel`,
                service: serviceName
            });
        }
    }
}
```

**Arquivo:** `api-gateway/server.js` (linhas 427-443)

```javascript
// Verifica√ß√£o de circuit breaker
isCircuitOpen(serviceName) {
    const breaker = this.circuitBreakers.get(serviceName);
    if (!breaker) return false;

    const now = Date.now();
    
    // Verificar se o circuito deve ser meio-aberto
    if (breaker.isOpen && (now - breaker.lastFailure) > 30000) { // 30 segundos
        breaker.isOpen = false;
        breaker.isHalfOpen = true;
        console.log(`Circuit breaker half-open for ${serviceName}`);
        return false;
    }

    return breaker.isOpen;
}
```

---

### **7. Service Registry - Estat√≠sticas e Monitoramento (Implementa√ß√£o Real)**

**Arquivo:** `lista-compras-microservices/shared/serviceRegistry.js` (linhas 142-178)

```javascript
// Obter estat√≠sticas do registry
getStats() {
    const services = this.readRegistry();
    const now = Date.now();
    
    const stats = {
        totalServices: Object.keys(services).length,
        healthyServices: 0,
        unhealthyServices: 0,
        averageUptime: 0,
        services: {}
    };
    
    let totalUptime = 0;
    
    Object.entries(services).forEach(([name, service]) => {
        const uptime = now - service.registeredAt;
        totalUptime += uptime;
        
        stats.services[name] = {
            healthy: service.healthy,
            uptime: uptime,
            lastHealthCheck: service.lastHealthCheck
        };
        
        if (service.healthy) {
            stats.healthyServices++;
        } else {
            stats.unhealthyServices++;
        }
    });
    
    if (stats.totalServices > 0) {
        stats.averageUptime = totalUptime / stats.totalServices;
    }
    
    return stats;
}
```

**Arquivo:** `lista-compras-microservices/shared/serviceRegistry.js` (linhas 184-195)

```javascript
// Cleanup autom√°tico na sa√≠da do processo
process.on('SIGINT', () => {
    console.log('\nüõë Limpando registry na sa√≠da...');
    serviceRegistry.cleanupInactiveServices(0); // Limpar todos
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Limpando registry na sa√≠da...');
    serviceRegistry.cleanupInactiveServices(0);
    process.exit(0);
});
```

---

## **Conclus√£o - Implementa√ß√£o Real no Projeto**

### **Consist√™ncia Garantida Atrav√©s De:**

1. ‚úÖ **Health Checks Autom√°ticos** - Monitoramento a cada 30 segundos
2. ‚úÖ **Circuit Breaker** - Prote√ß√£o com 3 falhas = circuito aberto
3. ‚úÖ **Service Registry** - Descoberta e cleanup autom√°tico de servi√ßos
4. ‚úÖ **JsonDatabase** - Gerenciamento robusto de dados JSON
5. ‚úÖ **Proxy com Failover** - Redirecionamento inteligente de requisi√ß√µes
6. ‚úÖ **Cleanup Autom√°tico** - Remo√ß√£o de servi√ßos inativos

### **Arquivos Implementados:**

- **`api-gateway/server.js`** - Health checks e circuit breaker
- **`lista-compras-microservices/shared/serviceRegistry.js`** - Registry e cleanup
- **`lista-compras-microservices/shared/JsonDatabase.js`** - Gerenciamento de dados
- **`services/*/server.js`** - Health check endpoints em cada servi√ßo

### **Benef√≠cios da Implementa√ß√£o Real:**

- üõ°Ô∏è **Resili√™ncia** - Sistema se recupera automaticamente
- üîÑ **Consist√™ncia** - Dados sempre √≠ntegros
- üìä **Observabilidade** - Monitoramento cont√≠nuo
- üöÄ **Disponibilidade** - Servi√ßos sempre funcionais
- üíæ **Database per Service** - Autonomia total de dados

**Resultado:** Um sistema robusto e funcional que garante consist√™ncia mesmo em cen√°rios de falha! üöÄ

---

## üìö **Refer√™ncias e Padr√µes**

### **Padr√µes Implementados:**
- ‚úÖ **Database per Service** - Autonomia de dados
- ‚úÖ **Saga Pattern** - Transa√ß√µes distribu√≠das
- ‚úÖ **Event Sourcing** - Rastreamento de mudan√ßas
- ‚úÖ **Circuit Breaker** - Prote√ß√£o contra falhas
- ‚úÖ **Health Check** - Monitoramento de sa√∫de

### **Tecnologias Utilizadas:**
- üîß **Node.js + Express** - Framework web
- üì° **Axios** - Cliente HTTP
- üìä **JSON** - Bancos NoSQL
- üîÑ **Async/Await** - Programa√ß√£o ass√≠ncrona
- üìÅ **fs-extra** - Opera√ß√µes de arquivo

### **Benef√≠cios Pedag√≥gicos:**
- üéì **Compreens√£o** de consist√™ncia distribu√≠da
- üèóÔ∏è **Implementa√ß√£o** de padr√µes de resili√™ncia
- üìà **Monitoramento** e observabilidade
- üîß **Recupera√ß√£o** autom√°tica de falhas
